---
- name: Add Docker repository
#  command: dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo
  yum_repository:
    name: docker-ce
    description: docker community edition
    baseurl: https://download.docker.com/linux/fedora/35/x86_64/stable/
    enabled: yes

- name: Remove docker systemd
  systemd:
    name: docker
    enabled: no
    state: stopped

- name: Remove containerd systemd
  systemd:
    name: containerd
    enabled: no
    state: stopped

- name: Remove Fedora versions of Docker
  package:
    name: "{{ item }}"
    state: absent
  loop:
    - docker
    - docker-common
    - docker-selinux
    - docker-engine

- name: Install packages used for containerization
  package:
    name: 
      - dnf-plugins-core #4.1.0
      - docker-ce #20.10.14
      - docker-ce-cli
      - containerd.io #1.5.11
      - skopeo #1.6.0
      - source-to-image #1.3.1
      - pass #1.7.4
      - jq #1.6
    state: present

- name: Create the docker group
  group:
    name: docker
    system: yes
    state: present

- name: Add user to the docker group
  user:
    name: "{{ ansible_user_id }}"
    groups: docker
    append: yes

- name: Write docker daemon file
  copy:
    content: |
      {
        "userns-remap": "default",
        "insecure-registries" : []
      }
    dest: /etc/docker/daemon.json
    owner: root
    group: docker
    mode: '0660'

- name: Write docker config file
  copy:
    content: |
      {
        "credsStore": "pass"
      }
    dest: /etc/docker/config.json
    owner: root
    group: docker
    mode: '0660'

- name: Configure docker-credential-pass
  unarchive:
    src: '{{ docker_credential_pass_url }}'
    remote_src: yes
    dest: /usr/local/bin
    attributes: '+x'

- name: Configure Docker to start on boot
  systemd:
    name: docker
    enabled: yes
    state: reloaded

- name: Configure containerd to start on boot
  systemd:
    name: containerd
    enabled: yes

- name: See if pass has been initialized
  become: false
  command: 'pass'
  register: pass_status
  ignore_errors: true

- name: Initialize pass
  become: false
  command: 'pass init {{ gpg_id }}'
  when: pass_status is failed

- name: Get latest version of kubectl
#  command: curl -L -s https://dl.k8s.io/release/stable.txt
  uri:
    url: https://dl.k8s.io/release/stable.txt
    return_content: yes
  register: kubectl_version

- name: Install kubectl binary
  get_url:
    url: 'https://dl.k8s.io/release/{{ kubectl_version.content }}/bin/linux/amd64/kubectl'
    dest: /usr/local/bin/kubectl
    mode: '755'
    group: 'docker'
    # checksum: 'sha256:https://dl.k8s.io/{{ kubectl_version.stdout_lines[0] }}/bin/linux/amd64/kubectl.sha256'

- name: Install kubectl-convert
  get_url:
    url: 'https://dl.k8s.io/release/{{ kubectl_version.content }}/bin/linux/amd64/kubectl-convert'
    dest: /usr/local/bin/kubectl-convert
    mode: '755'
    group: 'docker'
    # checksum: 'sha256:https://dl.k8s.io/{{ kubectl_version.stdout_lines[0] }}/bin/linux/amd64/kubectl-convert.sha256'

- name: Install minikube
  get_url:
    url: 'https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64'
    dest: /usr/local/bin/minikube
    mode: '755'
    group: 'docker'

- name: Download helm installer
  get_url:
    url: https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
    dest: /tmp/get_helm.sh
    mode: '700'

- name: Install helm
  command: bash /tmp/get_helm.sh

#- name: Fetch CodeReady Containers 
#  unarchive:
#    src: https://developers.redhat.com/content-gateway/rest/mirror/pub/openshift-v4/clients/crc/latest/crc-linux-amd64.tar.xz
#    dest: /usr/local/bin
#    group: 'docker'
#    remote_src: yes
#    extra_opts:
#      - '--strip-components=1'  

#- name: Cleanup CRC Install
#  file:
#    name: /usr/local/bin/LICENSE
#    state: absent

- name: Create dbuild
  copy:
    dest: /usr/local/bin/dbuild
    mode: '755'
    group: 'docker'
    content: |
      #!/bin/bash -e
      if [ -f "${PWD}/Dockerfile" ] && [ "${OC_PROJECT}" != "default" ]; then
              [[ ! -z "${OC_BUILDTARGET}" ]] && OC_BUILDTARGET=latest
              [[ ! -z "${OC_APPTARGET}" ]] && OC_APPTARGET=$(basename ${PWD} | tr '[:upper:]' '[:lower:]')

              docker build --pull --compress --tag=${OC_PUSHTARGET}/${OC_APPTARGET}:${OC_BUILDTARGET} .
              docker push ${OC_PUSHTARGET}/${OC_APPTARGET}:${OC_BUILDTARGET}
              #skopeo copy --dest-creds=${OC_USER}:${OC_TOKEN} $SRC $DEST

      else
              echo "No Dockerfile / on default."
      fi

- name: Create ocnewapp
  copy:
    dest: /usr/local/bin/ocnewapp
    mode: '755'
    group: 'docker'
    content: |
      #!/bin/bash -e
      # REQ: OC_APP_BUILDERIMAGE OC_APP_GITREPO OC_APP_BRANCH OC_APP_CONTEXTDIR OC_APP_LABEL

      CMD="oc new-app"
      FLAGS="--insecure-registry --as-deployment-config --binary=false"

      if [ ! -z "$OC_APP_BUILDERIMAGE" ]; then
              FLAGS="${FLAGS} --image=${OC_APP_BUILDERIMAGE} --strategy=source"
      fi

      if [ ! -z "$OC_APP_GITREPO" ]; then
              CMD="${CMD} --code=${OC_APP_GITREPO}"
      else
              CMD="${CMD} ."
      fi

      if [ ! -z "$OC_APP_BRANCH" ]; then
              CMD="${CMD}#${OC_APP_BRANCH}"
      fi

      if [ ! -z "$OC_APP_CONTEXTDIR" ]; then
              FLAGS="${FLAGS} --context-dir=${OC_APP_CONTEXTDIR}"
      fi

      if [ ! -z "$OC_APP_LABEL" ]; then
              FLAGS="${FLAGS} -l app=${OC_APP_LABEL} --name=${OC_APP_LABEL}"
      fi

      if [ -f ".os4/$OC_APP_LABEL/.buildenv" ]; then
              FLAGS="${FLAGS} --build-env-file=${PWD}/.os4/${OC_APP_LABEL}/.buildenv"
      fi

      if [ -f ".os4/$OC_APP_LABEL/.env" ]; then
              FLAGS="${FLAGS} --env-file=${PWD}/.os4/${OC_APP_LABEL}/.envvars"
      fi

      if [ -f ".os4/$OC_APP_LABEL/.param" ]; then
              FLAGS="${FLAGS} --param-file=${PWD}/.os4/${OC_APP_LABEL}/.param"
      fi

      mkdir -p /tmp/os4
      ${CMD} ${FLAGS} -o yaml | tee /tmp/os4/app.yaml
      ${CMD} ${FLAGS}
      echo ""
      echo "${CMD} ${FLAGS} sent to /tmp/os4/app.yaml"

